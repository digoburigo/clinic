//////////////////////////////////////////////////////////////////////////////////////////////
// DO NOT MODIFY THIS FILE                                                                  //
// This file is automatically generated by ZenStack CLI and should not be manually updated. //
//////////////////////////////////////////////////////////////////////////////////////////////

datasource db {
  provider = "sqlite"
  url      = env("DATABASE_URL")
}

generator client {
  provider = "prisma-client-js"
}

model Post {
  id             String        @id() @default(nanoid())
  title          String
  slug           String
  description    String?
  createdAt      DateTime      @default(now())
  updatedAt      DateTime      @updatedAt()
  ownerId        String
  owner          User          @relation(fields: [ownerId], references: [id], onDelete: Cascade)
  organizationId String?
  organization   Organization? @relation(fields: [organizationId], references: [id], onDelete: Cascade)

  @@index([slug])
}

model Cid {
  id          String @id() @default(nanoid())
  code        String
  description String

  @@unique([code])
}

model User {
  id            String       @id() @default(nanoid())
  name          String
  email         String
  emailVerified Boolean
  image         String?
  createdAt     DateTime     @default(now())
  updatedAt     DateTime     @updatedAt()
  sessions      Session[]
  accounts      Account[]
  members       Member[]
  invitations   Invitation[]
  posts         Post[]
  role          String?
  banned        Boolean?
  banReason     String?
  banExpires    DateTime?
  patientsOwner Patient[]    @relation("patientsOwner")
  patientUser   Patient[]    @relation("patientUser")

  @@unique([email])
  @@map("user")
}

model Session {
  id                   String   @id() @default(nanoid())
  expiresAt            DateTime
  token                String
  createdAt            DateTime @default(now())
  updatedAt            DateTime @updatedAt()
  ipAddress            String?
  userAgent            String?
  userId               String
  user                 User     @relation(fields: [userId], references: [id], onDelete: Cascade)
  impersonatedBy       String?
  activeOrganizationId String?

  @@unique([token])
  @@map("session")
}

model Account {
  id                    String    @id() @default(nanoid())
  accountId             String
  providerId            String
  userId                String
  user                  User      @relation(fields: [userId], references: [id], onDelete: Cascade)
  accessToken           String?
  refreshToken          String?
  idToken               String?
  accessTokenExpiresAt  DateTime?
  refreshTokenExpiresAt DateTime?
  scope                 String?
  password              String?
  createdAt             DateTime  @default(now())
  updatedAt             DateTime  @updatedAt()

  @@map("account")
}

model Verification {
  id         String   @id() @default(nanoid())
  identifier String
  value      String
  expiresAt  DateTime
  createdAt  DateTime @default(now())
  updatedAt  DateTime @updatedAt()

  @@map("verification")
}

model Organization {
  id          String       @id() @default(nanoid())
  name        String
  slug        String?
  logo        String?
  createdAt   DateTime     @default(now())
  updatedAt   DateTime     @updatedAt()
  metadata    String?
  members     Member[]
  invitations Invitation[]
  posts       Post[]
  patients    Patient[]

  @@unique([slug])
  @@map("organization")
}

model Member {
  id             String       @id() @default(nanoid())
  organizationId String
  organization   Organization @relation(fields: [organizationId], references: [id], onDelete: Cascade)
  userId         String
  user           User         @relation(fields: [userId], references: [id], onDelete: Cascade)
  role           String
  createdAt      DateTime     @default(now())
  updatedAt      DateTime     @updatedAt()

  @@map("member")
}

model Invitation {
  id             String       @id() @default(nanoid())
  organizationId String
  organization   Organization @relation(fields: [organizationId], references: [id], onDelete: Cascade)
  email          String
  role           String?
  status         String
  expiresAt      DateTime
  createdAt      DateTime     @default(now())
  inviterId      String
  user           User         @relation(fields: [inviterId], references: [id], onDelete: Cascade)

  @@map("invitation")
}

model Appointment {
  id        String   @id() @default(nanoid())
  patientId String
  patient   Patient  @relation(fields: [patientId], references: [id], onDelete: Cascade)
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt()
}

model Patient {
  id                String        @id() @default(nanoid())
  name              String
  cpf               String
  phone             String
  email             String
  gender            String
  responsible       String?
  nationality       String
  ethnicity         String
  state             String
  city              String
  zipCode           String
  neighborhood      String
  street            String
  number            String
  complement        String?
  occupation        String
  sexualOrientation String?
  maritalStatus     String
  bloodType         String
  genderIdentity    String
  vaccination       String
  allergies         String?
  medications       String?
  examResults       String?
  comorbidities     String?
  surgeries         String?
  healthInsurance   String
  password          String?
  createdAt         DateTime      @default(now())
  updatedAt         DateTime      @updatedAt()
  ownerId           String
  owner             User          @relation("patientsOwner", fields: [ownerId], references: [id], onDelete: Cascade)
  organizationId    String?
  organization      Organization? @relation(fields: [organizationId], references: [id], onDelete: Cascade)
  userId            String?
  user              User?         @relation("patientUser", fields: [userId], references: [id], onDelete: Cascade)
  appointments      Appointment[]

  @@unique([userId, organizationId])
}
