# Instructions

You are an expert in TypeScript, Node.js, Next.js App Router, React, Shadcn UI, Radix UI, TailwindCSS v4, Zod, React Hook Form, React Query, tRPC, Prisma, better-auth and ZenStack

During you interaction with the user, if you find anything reusable in this project (e.g. version of a library, model name), especially about a fix to a mistake you made or a correction you received, you should take note in the `Lessons` section in the `.cursorrules` file so you will not make the same mistake again.

You should also use the `.cursorrules` file as a scratchpad to organize your thoughts. Especially when you receive a new task, you should first review the content of the scratchpad, clear old different task if necessary, first explain the task, and plan the steps you need to take to complete the task. You can use todo markers to indicate the progress, e.g.
[X] Task 1
[ ] Task 2

Also update the progress of the task in the Scratchpad when you finish a subtask.
Especially when you finished a milestone, it will help to improve your depth of task accomplishment to use the scratchpad to reflect and plan.
The goal is to help you maintain a big picture as well as the progress of the task. Always refer to the Scratchpad when you plan the next step.

# Lessons

## Code Style and Structure

- Write concise, technical TypeScript code with accurate examples.
- Use functional and declarative programming patterns; avoid classes.
- Prefer iteration and modularization over code duplication.
- Use descriptive variable names with auxiliary verbs (e.g., isLoading, hasError).
- Structure files: exported component, subcomponents, helpers, static content, types.

1. **Minimal** - Absolute minimum code needed
   • 2. **Self-documenting** - Code explains itself through:

- Precise naming (verbs for functions, nouns for variables)
  •- Single-responsibility components
  •- Obvious data flow
  •- Add short comments when necessary

3. **Type-Exact** - Strict TypeScript types with zero
   any
4. **Secure** - Built-in security for auth/data handling
5. **Performant** - Follows Next.js optimization guides
   Before coding, make a plan inside a ‹thinking› tag.
6. Identify core requirement
7. Consider 3 implementation approaches
8. Choose simplest that meets needs
   • 4. Verify with these questions:
   ..•- Can this be split into smaller functions?
   •••- Are there unnecessary abstractions?
   •..•- Will this be clear to a junior dev?
   For example: <thinking>
   Let me think through this step by step.
   .. •
   </thinking>

## Naming Conventions

- Use lowercase with dashes for directories (e.g., components/auth-wizard).
- Favor named exports for components.

## TypeScript Usage

- Use TypeScript for all code; prefer interfaces over types.
- Avoid enums; use maps instead.
- Use functional components with TypeScript interfaces.

## Syntax and Formatting

- Use the "function" keyword for pure functions.
- Avoid unnecessary curly braces in conditionals; use concise syntax for simple statements.
- Use declarative JSX.

## UI and Styling

- Use Shadcn UI, Radix, and Tailwind for components and styling.
- Implement responsive design with Tailwind CSS; use a mobile-first approach.

## Performance Optimization

- Minimize 'use client', 'useEffect', and 'setState'; favor React Server Components (RSC) with tRPC on the server side.
- Wrap client components in Suspense with fallback.
- Use dynamic loading for non-critical components.
- Optimize images: use WebP format, include size data, implement lazy loading.

## Key Conventions

- Use 'nuqs' for URL search parameter state management.
- Optimize Web Vitals (LCP, CLS, FID).

## React Best Practices:

- Use functional components and hooks instead of class components
- Implement proper React memo and useMemo for performance optimization
- Follow the React hooks rules strictly to avoid common pitfalls
- Utilize React.lazy and Suspense for code-splitting and lazy loading
- Implement proper error boundaries to handle and display errors gracefully

## Next.js Standards:

- Utilize Next.js App Router for better performance and improved routing
- Implement proper error boundaries to handle server-side and client-side errors
- Use proper data fetching patterns with suspense and server components
- Leverage Next.js built-in optimizations like image optimization and automatic code splitting
- Implement proper internationalization and localization using Next.js i18n features

## TypeScript Practices:

- Use TypeScript strict mode for better type safety and catching potential errors
- Follow proper type definitions and use interfaces and types appropriately
- Implement comprehensive error handling with proper type guards and error types
- Utilize TypeScript's advanced features like conditional types and mapped types for complex scenarios
- Leverage TypeScript's module resolution and path aliases for better maintainability

## Prisma Best Practices:

- Use Prisma Client in a centralized manner to avoid multiple instances
- Implement proper error handling and logging for Prisma operations
- Utilize Prisma's type-safe query API for better maintainability and fewer runtime errors
- Leverage Prisma's relation fields and nested writes for efficient data modeling
- Implement proper migration strategies and version control for your Prisma schema

## Radix UI Best Practices:

- Utilize Radix UI components for consistent and accessible UI elements
- Customize Radix UI components using the provided APIs instead of modifying the core
- Implement proper accessibility features like ARIA attributes and keyboard navigation
- Leverage Radix UI's primitive components for building custom, accessible UI elements
- Follow Radix UI's best practices for theming and styling to maintain consistency

## tRPC best Practices:

- Structuring Routers and Procedures
- Techniques for organizing your API endpoints—such as grouping by data entity, separating CRUD operations, and using naming conventions for clarity.
- Input Validation and Type Safety
- Leveraging libraries like Zod for robust input validation to ensure type safety across client and server interactions.
- Error Handling and Middleware
- Implementing global error handlers, custom middleware, and strategies for managing exceptions in your tRPC procedures.
- Client Integration Best Practices
- Effective usage of tRPC with React Query (queries, mutations, subscriptions) in client frameworks (React, Next.js) including managing dependent queries.
- Optimizing Performance
- Strategies like SSR/SSG integration, request batching, caching (using React Query), and dynamic imports to reduce bundle size.
- Security Considerations
- Best practices for securing endpoints, handling authentication/authorization, and protecting your API from common vulnerabilities.
- Code Reusability and DRY Principles
- Tips for extracting shared logic, creating CRUD factories, and maintaining a clean, modular codebase.
- Testing and Debugging tRPC APIs
- Approaches for unit testing, integration testing, and effective debugging strategies for your tRPC procedures.

## React Query Best Practices:

- Use React Query for managing server state and data fetching
- Implement proper query keys and caching strategies for optimal performance
- Utilize React Query's mutation API for handling side effects and optimistic updates
- Implement proper error handling and loading states for a better user experience
- Leverage React Query's devtools for debugging and optimizing queries

## Zod Best Practices:

- Use Zod for runtime type checking and validation of data
- Implement proper error handling and user feedback for validation errors
- Utilize Zod's advanced features like refinements and transformations for complex validation
- Leverage Zod's integration with other libraries like React Hook Form for seamless validation
- Implement proper type inference and use Zod's inferred types for better type safety

## React Hook Form Best Practices:

- Use React Hook Form for managing form state and validation
- Implement proper form validation using Zod for better type safety
- Utilize React Hook Form's built-in features like controlled and uncontrolled inputs
- Implement proper error handling and user feedback for form validation
- Leverage React Hook Form's performance optimizations like lazy registration

## Tailwind CSS Best Practices:

- Use Tailwind CSS v4 for utility-first styling and rapid development
- Implement proper responsive design using Tailwind's responsive utilities
- Utilize Tailwind's custom theme configuration for consistent branding
- Implement proper accessibility features like focus states and screen reader support

## General Standards:

- Keep components small and focused for better maintainability
- Follow proper state management patterns like lifting state up or using context
- Implement proper testing practices with unit tests, integration tests, and end-to-end tests
- Utilize code linting and formatting tools for consistent code style and catching errors
- Implement proper security measures like input validation and secure data handling
